https://www.hackerrank.com/challenges/indexes-1/problem
How many index architecture type classifications are there in MS SQL Server?
üèÇ - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- 
Different types of Indexes in MySQL
Clustered indexes
Besides finding data quickly, indexes can also be used to optimize 
sort operations (order by) and physically arrange related data closely together.
This is process is called clustering of data.

Accessing a row through the clustered index is fast because 
the row data is on the same page where the index search leads. 
If a table is large, the clustered index architecture often saves a disk I/O operation, 
when compared to storage organizations that stores row data using a different page from the index record. 
(For example, MyISAM uses one file for data rows and another for index records.)

In InnoDB, the records in non-clustered indexes (also called secondary indexes) 
contain the primary key columns for the row that are not in the secondary index. 
InnoDB uses this primary key value to search for the row in the clustered index. 
If the primary key is long, the secondary indexes use more space, so it is advantageous to have a short primary key.

By default, with InnoDB, the primary index is a clustered index.

-- Comparison to Non-clustered indexes
All indexes are physically stored in order (a btree actually), so if we are returning 
just the column that is stored in the index, we‚Äôre still getting the same benefit. 
That is because the indexed column‚Äôs actual value is stored in the index, therefore 
MySQL will use the index value instead of reading the record. However, if we start retrieving columns 
that aren‚Äôt part of the index, this is where we want the actual records stored in order, 
such as they are with a clustered index.

-- Primary Key
A PRIMARY KEY is a unique index where all key columns must be defined as NOT NULL. 
If the primary key is not declared as NOT NULL, then MySQL declares them implicitly (and silently). 
A table can have only one PRIMARY KEY. The name of a PRIMARY KEY is always PRIMARY, 
which thus cannot be used as the name for any other kind of index.

-- Unique Key
A UNIQUE index creates a constraint such that all values in the index must be distinct. 
An error occurs if we try to add a new row with a key value that matches an existing row. 
For all engines, a UNIQUE index permits multiple NULL values for columns that contain NULL.

-- Normal Index
If it‚Äôs not primary or unique, it doesn‚Äôt constrain values inserted into the table, 
but it does allow them to be looked up more efficiently.

-- Full Text Index
It is a more specialized form of indexing that allows full text search. 
Think of it as (essentially) creating an ‚Äúindex‚Äù for each ‚Äúword‚Äù in the specified column. 
Up to 5.5 versions, this index is supported for MyISAM engine only but from 5.6 it supports both MyISAM and InnoDB engines.



https://www.hackerrank.com/challenges/indexes-2/problem
Which of the following statement is true about row locators in non-clustered indexes in MS SQL Server?
üèÇ - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- 
If the table does not have a clustered index, 
the row locator is the clustered index key for the row.

If the table has a clustered index, or the index is on an indexed view, 
the row locator is a pointer to the row.

(Y) If the table has a clustered index, or the index is on an indexed view, 
the row locator is the clustered index key for the row.



https://www.hackerrank.com/challenges/indexes-3/problem
Consider the following two designs to store the data using clustered indexes in MS SQL Server:
üèÇ - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- 
In the first design, the fill factor is 20% and the total number of free rows per page are A.

In the second design, the fill factor is 40% and the total number of free rows per page are B.

Which the followings describes the relation between A and B:

A ~80
B ~ 60
A = 1.33B


https://www.hackerrank.com/challenges/indexes-4/problem
The correct syntax for creating composite indexes in MS SQL Sever is:
üèÇ - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- - -- --- 
CREATE INDEX index_name
ON table_name(column1, column2);
